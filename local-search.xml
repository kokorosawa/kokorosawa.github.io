<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode.576</title>
    <link href="/2023/01/08/leetcode-576/"/>
    <url>/2023/01/08/leetcode-576/</url>
    
    <content type="html"><![CDATA[<h1 id="576-out-of-boundary-paths"><a class="markdownIt-Anchor" href="#576-out-of-boundary-paths">#</a> 576. Out of Boundary Paths</h1><p>There is an  <code>m x n</code>  grid with a ball. The ball is initially at the position  <code>[startRow, startColumn]</code> . You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply <strong>at most</strong>  <code>maxMove</code>  moves to the ball.</p><p>Given the five integers  <code>m</code> ,  <code>n</code> ,  <code>maxMove</code> ,  <code>startRow</code> ,  <code>startColumn</code> , return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it <strong>modulo</strong>  <code>109 + 7</code> .</p><span id="more"></span><h1 id="example-1"><a class="markdownIt-Anchor" href="#example-1">#</a> <strong>Example 1:</strong></h1><p><img src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png" alt="Untitled"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: m = <span class="hljs-number">2</span>, n = <span class="hljs-number">2</span>, maxMove = <span class="hljs-number">2</span>, startRow = <span class="hljs-number">0</span>, startColumn = <span class="hljs-number">0</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h1 id="example-2"><a class="markdownIt-Anchor" href="#example-2">#</a> <strong>Example 2:</strong></h1><p><img src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png" alt="Untitled"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: m = <span class="hljs-number">1</span>, n = <span class="hljs-number">3</span>, maxMove = <span class="hljs-number">3</span>, startRow = <span class="hljs-number">0</span>, startColumn = <span class="hljs-number">1</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>0 &lt;= maxMove &lt;= 50</code></li><li><code>0 &lt;= startRow &lt; m</code></li><li><code>0 &lt;= startColumn &lt; n</code></li></ul><h1 id="my-solution"><a class="markdownIt-Anchor" href="#my-solution">#</a> My Solution :</h1><h2 id="一開始僅使用一般-dfs-來尋找突破邊界的路徑"><a class="markdownIt-Anchor" href="#一開始僅使用一般-dfs-來尋找突破邊界的路徑">#</a> 一開始僅使用一般 DFS 來尋找突破邊界的路徑</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(m, n, startRow, startColumn, maxMove);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> move)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row &gt; m - <span class="hljs-number">1</span> || col &gt; n - <span class="hljs-number">1</span> || row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span>)&#123;<br>            ans++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(move == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">dfs</span>(m, n, row - <span class="hljs-number">1</span>, col, move - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">dfs</span>(m, n, row + <span class="hljs-number">1</span>, col, move - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">dfs</span>(m, n, row, col + <span class="hljs-number">1</span>, move - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">dfs</span>(m, n, row, col - <span class="hljs-number">1</span>, move - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但在繳交後發現會 TLE，原因為，，第三個維度紀錄步數</p><p>所以利用三維陣列來記錄已已經搜索過的路徑，第三個維度紀錄走到當前座標的步數有幾個方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> mp[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>][<span class="hljs-number">51</span>];<br></code></pre></td></tr></table></figure><p>並利用 memset 來初始化陣列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(mp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(mp));<br><span class="hljs-comment">//     記憶體位址, 初始化值, 陣列大小</span><br></code></pre></td></tr></table></figure><h1 id="code"><a class="markdownIt-Anchor" href="#code">#</a> Code :</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> mp[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>][<span class="hljs-number">51</span>];<br>    <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> </span>&#123;<br>        <span class="hljs-built_in">memset</span>(mp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(mp));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(m, n, startRow, startColumn, maxMove);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> move)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row &gt; m - <span class="hljs-number">1</span> || col &gt; n - <span class="hljs-number">1</span> || row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(move == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(mp[row][col][move] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> mp[row][col][move];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> curr = <span class="hljs-number">0</span>;<br>        curr += (<span class="hljs-built_in">dfs</span>(m, n, row - <span class="hljs-number">1</span>, col, move - <span class="hljs-number">1</span>) % M);<br>        curr += (<span class="hljs-built_in">dfs</span>(m, n, row + <span class="hljs-number">1</span>, col, move - <span class="hljs-number">1</span>) % M);<br>        curr += (<span class="hljs-built_in">dfs</span>(m, n, row, col + <span class="hljs-number">1</span>, move - <span class="hljs-number">1</span>) % M);<br>        curr += (<span class="hljs-built_in">dfs</span>(m, n, row, col - <span class="hljs-number">1</span>, move - <span class="hljs-number">1</span>) % M);<br>        curr %= M;<br>        <span class="hljs-keyword">return</span> mp[row][col][move] = curr;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>記得在最後記錄在陣列中的值必須 % 1000000007，</p><p>因為在題目方形極大的情況下，可能的路徑會很多，並造成 int 溢位</p><h1 id="question"><a class="markdownIt-Anchor" href="#question">#</a> Question :</h1><hr><p>Q : 我們在不同的路徑會多次來到同一個坐標嗎？</p><p>A : 會</p><p>Q：如果來到同一個坐標，但步數不同，屬於同一個狀態嗎？</p><p>A：不屬於，很明顯步數不同時，它們接下來的路徑也會不同。</p><p>Q：步數相同，坐標相同時，接下來的路徑數量是否一致？</p><p>A：必定一致，且在 DFS 搜索過程中會多次遇到之前來過的坐標、步數相同的狀態</p><p>答案<a href="https://leetcode.cn/problems/out-of-boundary-paths/solution/576-chu-jie-de-lu-jing-shu-ji-yi-hua-sou-7sg4/">出處</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
